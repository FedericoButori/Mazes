# Mazes
So, the first project I decided to work on is a maze solver. 

I got this idea watching a video on YouTube from Computerphile and decided it was a nice 
project to start implementing some stuff in Python.

The first intuition I got from the video was to use graphs to model the problem.
Also, I found out that there is way of implementing graphs using dictionaries (another 
possibility I thought of later on was to use matrix) so I decided to take up this problem
as a way to revise and learn more about dictionaries and how they work.

The script takes a BnW image (i worked with mazes generated by 
https://keesiemeijer.github.io/maze-generator/#generate ) and arranges it into a variable 
"maze" which is a matrix of 0's and 1's where 0 represent a wall and 1 a possible path.

Next, it creates a graph as a dictionary with keys (i, j) where i and j are the indexes of
a white pixel in the matrix and values a list of all the nodes adjacent to (i, j).
Then it adds the nodes representing the entrance and the exit of the maze.

After that, I decided that i wanted to find a way to remove all the dead ends before starting
the search for a path, in order to speed things up and work on a much smaller graph.
To do so I created a function pop_leaves that reiterately removes all the leaves of the graph
(meaning all the node with only one adjacent node) until the only leaves left are the starting 
and end point.

Finally, I implemented a function find_path copying the classic path finder algorithm for graph.
Basically it recursively looks for possible paths and terminates when it reaches the desired 
path recording all the nodes that it went through.

It surpised me to see that for the mazes I used (which only allowed one solution, so no loops)
cutting down all the dead ends from the graph actually resulted in a solving path.

Unfortunately, the function find_path does not work (i.e. reaches the maximum depth for 
recursion allowed) for mazes quite big because, even with the trimming of the dead ends, the 
graphs still had a lot of nodes. The next improvement I was considering was to remove all the 
nodes that represent a point in the middle of a "corridor" (i.e. from which you can only go up
and down or left and right). This should leave us with only "important" nodes, meaning nodes 
that represents a junction, a change of direction.





